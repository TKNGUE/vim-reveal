" Vim global plugin for correcting typing mistakes
" Contribute
" Author:       farseer90718
" Contirubtor:  TKNGUE <mnct.tkn3011@gmail.com>
" Last Change:  2014-06-24
"
if exists("g:loaded_reveal")
    finish
endif 
let g:loaded_reveal = 1

let s:save_cpo = &cpo
set cpo&vim

let s:newline_character = "\n"
if exists('g:reveal_root_path')   
    g:reveal_root_path  = $HOME.'/reveal.js/'
endif

let s:template_path = expand('<sfile>:p:h').'/../template/'
let s:default_config = {
            \'controls': 'true',
            \'progress': 'true',
            \'history': 'false',
            \'keyboard': 'true',
            \'touch': 'true',
            \'center': 'true',
            \'loop': 'false',
            \'rtl': 'false',
            \'mouseWheel': 'false',
            \'margin': '0.1',
            \'minScale': '0.2',
            \'maxScale': '1.0',
            \'autoSlide': '0',
            \'width': '960',
            \'height': '900',
            \'theme': '"default"',
            \'transition': '"default"',
            \'transitionSpeed': '"default"',
            \'backgroundTransition': '"default"',
            \'fname': 'reveal',
            \'title': 'title',
            \'author':'"author"',
            \'description':'"This presentation is generated by vim-reveal and reveal.js."'}

function! reveal#open(preview_html_file)
    call reveal#refresh()
    if exists('g:reveal_open_cmd') && !empty(g:reveal_open_cmd)
        execute printf('silent !"%s" "%s"', g:reveal_open_cmd, a:preview_html_file)
    elseif s:exists_openbrowser()
        call s:apply_openbrowser(a:preview_html_file)
    else
        echoerr 'Not found command for open. show detail :h reveal#open'
    endif
endfunction

function! s:exists_openbrowser()
    try
        call openbrowser#load()
        return 1
    catch /e117.*/
        return 0
    endtry
endfunction

function! s:apply_openbrowser(path)
    let saved_in_vim = g:openbrowser_open_filepath_in_vim
    try
        let g:openbrowser_open_filepath_in_vim = 0
        call openbrowser#open(a:path)
    finally
        let g:openbrowser_open_filepath_in_vim = saved_in_vim
    endtry
endfunction

function! reveal#refresh()
    call reveal#Md2Reveal()
endfunction

function! reveal#preview_file_path() 
    call s:update_config()
    return g:reveal_root_path . s:default_config['fname'] . '.html'
endfunction
  
function! s:update_config()  
    "Append slash for direcotry path if path doesn't end with slash 
    let g:reveal_root_path = expand(g:reveal_root_path)
    let g:reveal_root_path =   
                \ g:reveal_root_path =~ '\/$' ?   
                \ g:reveal_root_path : g:reveal_root_path.'/'
    if exists('g:reveal_default_config')
        for [key,value] in items(g:reveal_default_config)
            let s:default_config[key] = value
        endfor
    endif        
endfunction 

function! reveal#Md2Reveal()
    let Metadata = s:GetMetadata()
    for [key,value] in items(s:default_config)
        if !has_key(Metadata, key)
            let Metadata[key] = value
        endif
    endfor

    " Generate html file for reveal.js "
    let fname = reveal#preview_file_path()
    let body_lines = s:GetContent()
    let head_lines = readfile( s:template_path.'head')
    let tail_lines = readfile( s:template_path.'tail')

    let contents = []
    for line in head_lines
        for [mkey, mvalue] in items(Metadata)
            let ptn = "{%\\s*" . mkey . '\s*%}'
            let line = substitute(line, ptn, mvalue, 'g')
        endfor
        call add(contents, line) 
    endfor

    for line in body_lines
        call add(contents, line) 
    endfor

    for line in tail_lines
        for [mkey, mvalue] in items(Metadata)
            let ptn = "{%\\s*" . mkey . '\s*%}'
            let line = substitute(line, ptn, mvalue, 'g')
        endfor
        call add(contents, line) 
    endfor

    call writefile(contents, fname)
endfunction


function! s:GetContent()
    let content = []
    normal gg
    while 1
        let line1 = search('^\s*<!--\s*sec.*-->\s*$', 'eW')
        let line2 = search('^\s*<!--\s*sec.*-->\s*$', 'nW')
        let secno1 = matchstr(getline(line1), 'secp\=\s*\zs\d\+')
        let secno2 = matchstr(getline(line2), 'secp\=\s*\zs\d\+')
        let subsecno = matchstr(getline(line1), 'secp\=\s*\d\+\.\zs\d\+')
        let sectype = matchstr(getline(line1), 'sec\zs.')
        let opt = matchstr(getline(line1), 'secp\=\s*[.0-9]*\s*\zs.*\ze-->')
        let opt = substitute(opt, 'bgtr=', 'data-background-transition=', 'g')
        let opt = substitute(opt, 'bgrp=', 'data-background-repeat=', 'g')
        let opt = substitute(opt, 'bgsz=', 'data-background-size=', 'g')
        let opt = substitute(opt, 'bg=', 'data-background=', 'g')
        let opt = substitute(opt, 'tr=', 'data-transition=', 'g')
        let endlineno = line2? line2-1: line('$')
        if line1
            let sechead = ['<section data-markdown '.opt.'>']
            let sectail = ['</section>']
            let subhead = ['<script type="text/template">']
            let subtail = ['</script>']
            if sectype == 'p'
                let sechead = ['<section '.opt.'>']
                let subhead = []
                let subtail = []
            endif
            if secno1 == secno2
                if subsecno =~ '^1\=$'
                    let sechead = ['<section>']+sechead
                endif
            elseif subsecno != ''
                let sectail = sectail+sectail
            endif
            let content += sechead+subhead+getline(line('.')+1, endlineno)+subtail+sectail
        endif
        if line2 == 0
            return content
        endif
    endwhile
endfunction

function! s:GetMetadata()
    let Metadata = {}
    let lineno = 1
    while getline(lineno) =~ '^\(<!--Meta\s\+.*-->\)'
        execute lineno
        let line = getline(lineno)  
        let line = substitute(line, '\s\{2,}', '  ', 'g')
        let config_list = split(matchstr(line, '^<!--Meta\s\+\zs.*\ze-->.*'), '  ') 
        for data  in config_list
            let key = matchstr(data, '\w\+\ze\s*:')
            let val = matchstr(data, ':\s*\zs.\+\ze\s*')
            if key != ''
                let Metadata[key] = val
            endif
        endfor
        let lineno += 1
    endwhile
    return Metadata
endfunction

let &cpo = s:save_cpo
unlet s:save_cpo
